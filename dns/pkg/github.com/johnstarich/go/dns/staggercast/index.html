<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta name="theme-color" content="#375EAB">

  <title>staggercast - GoPages</title>

<link type="text/css" rel="stylesheet" href="/go/dns/lib/godoc/style.css">

<script>window.initFuncs = [];</script>
<script src="/go/dns/lib/godoc/jquery.js" defer></script>



<script>var goVersion = "go1.13.11";</script>
<script src="/go/dns/lib/godoc/godocs.js" defer></script>
</head>
<body>

<div id='lowframe' style="position: fixed; bottom: 0; left: 0; height: 0; width: 100%; border-top: thin solid grey; background-color: white; overflow: auto;">
...
</div><!-- #lowframe -->

<div id="topbar" class="wide"><div class="container">
<div class="top-heading" id="heading-wide"><a href="/go/dns/pkg/">GoPages | Auto-generated docs</a></div>
<div class="top-heading" id="heading-narrow"><a href="/go/dns/pkg/">GoPages</a></div>
<a href="#" id="menu-button"><span id="menu-button-arrow">&#9661;</span></a>

</div></div>



<div id="page" class="wide">
<div class="container">


  <h1>
    Package staggercast
    <span class="text-muted"></span>
  </h1>







<div id="nav"></div>


<!--
	Copyright 2009 The Go Authors. All rights reserved.
	Use of this source code is governed by a BSD-style
	license that can be found in the LICENSE file.
-->
<!--
	Note: Static (i.e., not template-generated) href and id
	attributes start with "pkg-" to make it impossible for
	them to conflict with generated attributes (some of which
	correspond to Go identifiers).
-->

	<script>
	document.ANALYSIS_DATA = null;
	document.CALLGRAPH = null;
	</script>

	
		
		<div id="short-nav">
			<dl>
			<dd><code>import "github.com/johnstarich/go/dns/staggercast"</code></dd>
			</dl>
			<dl>
			<dd><a href="#pkg-overview" class="overviewLink">Overview</a></dd>
			<dd><a href="#pkg-index" class="indexLink">Index</a></dd>
			
			
			</dl>
		</div>
		<!-- The package's Name is printed as title by the top-level template -->
		<div id="pkg-overview" class="toggleVisible">
			<div class="collapsed">
				<h2 class="toggleButton" title="Click to show Overview section">Overview ▹</h2>
			</div>
			<div class="expanded">
				<h2 class="toggleButton" title="Click to hide Overview section">Overview ▾</h2>
				
				
			</div>
		</div>

		<div id="pkg-index" class="toggleVisible">
		<div class="collapsed">
			<h2 class="toggleButton" title="Click to show Index section">Index ▹</h2>
		</div>
		<div class="expanded">
			<h2 class="toggleButton" title="Click to hide Index section">Index ▾</h2>

		<!-- Table of contents for API; must be named manual-nav to turn off auto nav. -->
			<div id="manual-nav">
			<dl>
			
			
			
			
				
				<dd><a href="#Conn">type Conn</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#New">func New(conns []PacketConn) Conn</a></dd>
				
				
			
				
				<dd><a href="#PacketConn">type PacketConn</a></dd>
				
				
			
				
				<dd><a href="#Stats">type Stats</a></dd>
				
				
			
				
				<dd><a href="#connOp">type connOp</a></dd>
				
				
			
				
				<dd><a href="#staggerConn">type staggerConn</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#staggerConn.Close">func (s *staggerConn) Close() error</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#staggerConn.LocalAddr">func (s *staggerConn) LocalAddr() net.Addr</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#staggerConn.Read">func (s *staggerConn) Read(b []byte) (n int, err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#staggerConn.ReadFrom">func (s *staggerConn) ReadFrom(b []byte) (n int, addr net.Addr, err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#staggerConn.RemoteAddr">func (s *staggerConn) RemoteAddr() net.Addr</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#staggerConn.SetDeadline">func (s *staggerConn) SetDeadline(t time.Time) error</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#staggerConn.SetReadDeadline">func (s *staggerConn) SetReadDeadline(t time.Time) error</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#staggerConn.SetWriteDeadline">func (s *staggerConn) SetWriteDeadline(t time.Time) error</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#staggerConn.Stagger">func (s *staggerConn) Stagger(ticker &lt;-chan struct{}, cancel context.CancelFunc)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#staggerConn.Stats">func (s *staggerConn) Stats() Stats</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#staggerConn.Write">func (s *staggerConn) Write(b []byte) (n int, err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#staggerConn.WriteTo">func (s *staggerConn) WriteTo(b []byte, addr net.Addr) (n int, err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#staggerConn.getConnCount">func (s *staggerConn) getConnCount() int</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#staggerConn.iter">func (s *staggerConn) iter(op connOp, fn func(conn PacketConn) (keepGoing bool, err error)) error</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#staggerConn.runReplay">func (s *staggerConn) runReplay(connIndex uint64)</a></dd>
				
			
			
			</dl>
			</div><!-- #manual-nav -->

		

		
			<h3>Package files</h3>
			<p>
			<span style="font-size:90%">
			
				<a href="/go/dns/src/github.com/johnstarich/go/dns/staggercast/conn.go">conn.go</a>
			
			</span>
			</p>
		
		</div><!-- .expanded -->
		</div><!-- #pkg-index -->

		

		
		
		
		
			
			
			<h2 id="Conn">type <a href="/go/dns/src/github.com/johnstarich/go/dns/staggercast/conn.go#L17">Conn</a>
				<a class="permalink" href="#Conn">&#xb6;</a>
				
				
			</h2>
			
			<pre>type Conn interface {
    <a href="#PacketConn">PacketConn</a>
    Stagger(ticker &lt;-chan struct{}, cancel <a href="/pkg/context/">context</a>.<a href="/pkg/context/#CancelFunc">CancelFunc</a>)
    Stats() <a href="#Stats">Stats</a>
}</pre>

			

			

			
			
			

			
				
				<h3 id="New">func <a href="/go/dns/src/github.com/johnstarich/go/dns/staggercast/conn.go#L55">New</a>
					<a class="permalink" href="#New">&#xb6;</a>
					
					
				</h3>
				<pre>func New(conns []<a href="#PacketConn">PacketConn</a>) <a href="#Conn">Conn</a></pre>
				
				
				
			

			
		
			
			
			<h2 id="PacketConn">type <a href="/go/dns/src/github.com/johnstarich/go/dns/staggercast/conn.go#L24">PacketConn</a>
				<a class="permalink" href="#PacketConn">&#xb6;</a>
				
				
			</h2>
			<p>
PacketConn implements both net.Conn and net.PacketConn
</p>

			<pre>type PacketConn interface {
    <a href="/pkg/io/">io</a>.<a href="/pkg/io/#Reader">Reader</a>
    <a href="/pkg/io/">io</a>.<a href="/pkg/io/#Writer">Writer</a>
    RemoteAddr() <a href="/pkg/net/">net</a>.<a href="/pkg/net/#Addr">Addr</a>
    <a href="/pkg/net/">net</a>.<a href="/pkg/net/#PacketConn">PacketConn</a>
}</pre>

			

			

			
			
			

			

			
		
			
			
			<h2 id="Stats">type <a href="/go/dns/src/github.com/johnstarich/go/dns/staggercast/conn.go#L31">Stats</a>
				<a class="permalink" href="#Stats">&#xb6;</a>
				
				
			</h2>
			
			<pre>type Stats struct {
<span id="Stats.FastestRemoteIndex"></span>    FastestRemoteIndex <a href="/pkg/builtin/#int">int</a>
<span id="Stats.FastestRemote"></span>    FastestRemote      <a href="/pkg/net/">net</a>.<a href="/pkg/net/#Addr">Addr</a>
}
</pre>

			

			

			
			
			

			

			
		
			
			
			<h2 id="connOp">type <a href="/go/dns/src/github.com/johnstarich/go/dns/staggercast/conn.go#L131">connOp</a>
				<a class="permalink" href="#connOp">&#xb6;</a>
				
				
			</h2>
			
			<pre>type connOp <a href="/pkg/builtin/#string">string</a></pre>

			
				
				<pre>const (
    <span id="readOp">readOp</span>             connOp = &#34;read&#34;
    <span id="writeOp">writeOp</span>            connOp = &#34;write&#34;
    <span id="readFromOp">readFromOp</span>         connOp = &#34;read from&#34;
    <span id="writeToOp">writeToOp</span>          connOp = &#34;write to&#34;
    <span id="setDeadlineOp">setDeadlineOp</span>      connOp = &#34;set deadline&#34;
    <span id="setReadDeadlineOp">setReadDeadlineOp</span>  connOp = &#34;set read deadline&#34;
    <span id="setWriteDeadlineOp">setWriteDeadlineOp</span> connOp = &#34;set write deadline&#34;
)</pre>
			

			

			
			
			

			

			
		
			
			
			<h2 id="staggerConn">type <a href="/go/dns/src/github.com/johnstarich/go/dns/staggercast/conn.go#L37">staggerConn</a>
				<a class="permalink" href="#staggerConn">&#xb6;</a>
				
				
			</h2>
			<p>
staggerConn fires out all Writes to all outgoing connections, Reads return the first successful read.
</p>

			<pre>type staggerConn struct {
<span id="staggerConn.conns"></span>    conns []<a href="#PacketConn">PacketConn</a>

<span id="staggerConn.connCount"></span>    connCount    *<a href="/pkg/go.uber.org/atomic/">atomic</a>.<a href="/pkg/go.uber.org/atomic/#Uint64">Uint64</a>
<span id="staggerConn.replay"></span>    replay       []chan struct{}
<span id="staggerConn.replayMu"></span>    replayMu     <a href="/pkg/sync/">sync</a>.<a href="/pkg/sync/#RWMutex">RWMutex</a>
<span id="staggerConn.tickerCancel"></span>    tickerCancel <a href="/pkg/context/">context</a>.<a href="/pkg/context/#CancelFunc">CancelFunc</a>
    <span class="comment">// capture last Write and SetDeadlines for replay on staggered connections</span>
<span id="staggerConn.lastDeadline"></span>    lastDeadline,
    lastReadDeadline,
    lastWriteDeadline <a href="/pkg/time/">time</a>.<a href="/pkg/time/#Time">Time</a>
<span id="staggerConn.lastWrite"></span>    lastWrite     []<a href="/pkg/builtin/#byte">byte</a>
<span id="staggerConn.lastWriteAddr"></span>    lastWriteAddr <a href="/pkg/net/">net</a>.<a href="/pkg/net/#Addr">Addr</a> <span class="comment">// currently unused in replay</span>

    <span class="comment">// capture stats about connections for better ordering on the next call to staggercast.New</span>
<span id="staggerConn.firstResponder"></span>    firstResponder *<a href="/pkg/go.uber.org/atomic/">atomic</a>.<a href="/pkg/go.uber.org/atomic/#Int64">Int64</a>
}
</pre>

			

			

			
			
			

			

			
				
				<h3 id="staggerConn.Close">func (*staggerConn) <a href="/go/dns/src/github.com/johnstarich/go/dns/staggercast/conn.go#L319">Close</a>
					<a class="permalink" href="#staggerConn.Close">&#xb6;</a>
					
					
				</h3>
				<pre>func (s *staggerConn) Close() <a href="/pkg/builtin/#error">error</a></pre>
				
				
				
				
			
				
				<h3 id="staggerConn.LocalAddr">func (*staggerConn) <a href="/go/dns/src/github.com/johnstarich/go/dns/staggercast/conn.go#L333">LocalAddr</a>
					<a class="permalink" href="#staggerConn.LocalAddr">&#xb6;</a>
					
					
				</h3>
				<pre>func (s *staggerConn) LocalAddr() <a href="/pkg/net/">net</a>.<a href="/pkg/net/#Addr">Addr</a></pre>
				
				
				
				
			
				
				<h3 id="staggerConn.Read">func (*staggerConn) <a href="/go/dns/src/github.com/johnstarich/go/dns/staggercast/conn.go#L213">Read</a>
					<a class="permalink" href="#staggerConn.Read">&#xb6;</a>
					
					
				</h3>
				<pre>func (s *staggerConn) Read(b []<a href="/pkg/builtin/#byte">byte</a>) (n <a href="/pkg/builtin/#int">int</a>, err <a href="/pkg/builtin/#error">error</a>)</pre>
				
				
				
				
			
				
				<h3 id="staggerConn.ReadFrom">func (*staggerConn) <a href="/go/dns/src/github.com/johnstarich/go/dns/staggercast/conn.go#L264">ReadFrom</a>
					<a class="permalink" href="#staggerConn.ReadFrom">&#xb6;</a>
					
					
				</h3>
				<pre>func (s *staggerConn) ReadFrom(b []<a href="/pkg/builtin/#byte">byte</a>) (n <a href="/pkg/builtin/#int">int</a>, addr <a href="/pkg/net/">net</a>.<a href="/pkg/net/#Addr">Addr</a>, err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
ReadFrom implements net.PacketConn, but is unused for UDP DNS queries. May require further testing for other use cases.
</p>

				
				
				
			
				
				<h3 id="staggerConn.RemoteAddr">func (*staggerConn) <a href="/go/dns/src/github.com/johnstarich/go/dns/staggercast/conn.go#L338">RemoteAddr</a>
					<a class="permalink" href="#staggerConn.RemoteAddr">&#xb6;</a>
					
					
				</h3>
				<pre>func (s *staggerConn) RemoteAddr() <a href="/pkg/net/">net</a>.<a href="/pkg/net/#Addr">Addr</a></pre>
				
				
				
				
			
				
				<h3 id="staggerConn.SetDeadline">func (*staggerConn) <a href="/go/dns/src/github.com/johnstarich/go/dns/staggercast/conn.go#L343">SetDeadline</a>
					<a class="permalink" href="#staggerConn.SetDeadline">&#xb6;</a>
					
					
				</h3>
				<pre>func (s *staggerConn) SetDeadline(t <a href="/pkg/time/">time</a>.<a href="/pkg/time/#Time">Time</a>) <a href="/pkg/builtin/#error">error</a></pre>
				
				
				
				
			
				
				<h3 id="staggerConn.SetReadDeadline">func (*staggerConn) <a href="/go/dns/src/github.com/johnstarich/go/dns/staggercast/conn.go#L352">SetReadDeadline</a>
					<a class="permalink" href="#staggerConn.SetReadDeadline">&#xb6;</a>
					
					
				</h3>
				<pre>func (s *staggerConn) SetReadDeadline(t <a href="/pkg/time/">time</a>.<a href="/pkg/time/#Time">Time</a>) <a href="/pkg/builtin/#error">error</a></pre>
				
				
				
				
			
				
				<h3 id="staggerConn.SetWriteDeadline">func (*staggerConn) <a href="/go/dns/src/github.com/johnstarich/go/dns/staggercast/conn.go#L361">SetWriteDeadline</a>
					<a class="permalink" href="#staggerConn.SetWriteDeadline">&#xb6;</a>
					
					
				</h3>
				<pre>func (s *staggerConn) SetWriteDeadline(t <a href="/pkg/time/">time</a>.<a href="/pkg/time/#Time">Time</a>) <a href="/pkg/builtin/#error">error</a></pre>
				
				
				
				
			
				
				<h3 id="staggerConn.Stagger">func (*staggerConn) <a href="/go/dns/src/github.com/johnstarich/go/dns/staggercast/conn.go#L83">Stagger</a>
					<a class="permalink" href="#staggerConn.Stagger">&#xb6;</a>
					
					
				</h3>
				<pre>func (s *staggerConn) Stagger(ticker &lt;-chan struct{}, cancel <a href="/pkg/context/">context</a>.<a href="/pkg/context/#CancelFunc">CancelFunc</a>)</pre>
				<p>
Stagger controls when secondary connections are attempted after the first. For any new enabled connection, the last Write and SetDeadlines are replayed onto it.
If Stagger is called after the connection is started, then the behavior is undefined.
First connection is attempted immediately, then all future connections will be enabled when receiving from ticker.
</p>
<p>
Example: Create and wrap a &#39;time.Ticker.C&#39; with a duration of 1 second.
The first connection is attempted immediately. For every 1 second the Read hasn&#39;t returned, an additional connection is attempted.
Once a connection succeeds, the result is returned immediately from Read.
</p>

				
				
				
			
				
				<h3 id="staggerConn.Stats">func (*staggerConn) <a href="/go/dns/src/github.com/johnstarich/go/dns/staggercast/conn.go#L120">Stats</a>
					<a class="permalink" href="#staggerConn.Stats">&#xb6;</a>
					
					
				</h3>
				<pre>func (s *staggerConn) Stats() <a href="#Stats">Stats</a></pre>
				
				
				
				
			
				
				<h3 id="staggerConn.Write">func (*staggerConn) <a href="/go/dns/src/github.com/johnstarich/go/dns/staggercast/conn.go#L241">Write</a>
					<a class="permalink" href="#staggerConn.Write">&#xb6;</a>
					
					
				</h3>
				<pre>func (s *staggerConn) Write(b []<a href="/pkg/builtin/#byte">byte</a>) (n <a href="/pkg/builtin/#int">int</a>, err <a href="/pkg/builtin/#error">error</a>)</pre>
				
				
				
				
			
				
				<h3 id="staggerConn.WriteTo">func (*staggerConn) <a href="/go/dns/src/github.com/johnstarich/go/dns/staggercast/conn.go#L296">WriteTo</a>
					<a class="permalink" href="#staggerConn.WriteTo">&#xb6;</a>
					
					
				</h3>
				<pre>func (s *staggerConn) WriteTo(b []<a href="/pkg/builtin/#byte">byte</a>, addr <a href="/pkg/net/">net</a>.<a href="/pkg/net/#Addr">Addr</a>) (n <a href="/pkg/builtin/#int">int</a>, err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
WriteTo implements net.PacketConn, but is unused for UDP DNS queries. May require further testing for other use cases.
</p>

				
				
				
			
				
				<h3 id="staggerConn.getConnCount">func (*staggerConn) <a href="/go/dns/src/github.com/johnstarich/go/dns/staggercast/conn.go#L163">getConnCount</a>
					<a class="permalink" href="#staggerConn.getConnCount">&#xb6;</a>
					
					
				</h3>
				<pre>func (s *staggerConn) getConnCount() <a href="/pkg/builtin/#int">int</a></pre>
				
				
				
				
			
				
				<h3 id="staggerConn.iter">func (*staggerConn) <a href="/go/dns/src/github.com/johnstarich/go/dns/staggercast/conn.go#L171">iter</a>
					<a class="permalink" href="#staggerConn.iter">&#xb6;</a>
					
					
				</h3>
				<pre>func (s *staggerConn) iter(op connOp, fn func(conn <a href="#PacketConn">PacketConn</a>) (keepGoing <a href="/pkg/builtin/#bool">bool</a>, err <a href="/pkg/builtin/#error">error</a>)) <a href="/pkg/builtin/#error">error</a></pre>
				
				
				
				
			
				
				<h3 id="staggerConn.runReplay">func (*staggerConn) <a href="/go/dns/src/github.com/johnstarich/go/dns/staggercast/conn.go#L144">runReplay</a>
					<a class="permalink" href="#staggerConn.runReplay">&#xb6;</a>
					
					
				</h3>
				<pre>func (s *staggerConn) runReplay(connIndex <a href="/pkg/builtin/#uint64">uint64</a>)</pre>
				<p>
runReplay synchronously reapplies the last Deadlines and the last Write on a best-effort basis
</p>

				
				
				
			
		
	

	







<div id="footer">
Build version go1.13.11.<br>
</div>

</div><!-- .container -->
</div><!-- #page -->
</body>
</html>
